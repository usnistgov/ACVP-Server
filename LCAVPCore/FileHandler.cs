using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;

namespace LCAVPCore
{
	public class FileHandler
	{
		private int _folderCount;		//"Global" count since the value is needed by things that iterate and recurse
		private string _extractionPath;
		private string _extractedFilesRoot;
		private SubmissionType _submissionType;


		public FileHandler(SubmissionType submissionType, string extractedFilesRoot)
		{
			_submissionType = submissionType;
			_extractedFilesRoot = extractedFilesRoot;
		}

		public FileExtractionResult ExtractZip(string zipFilePath)
		{
			_folderCount = 0;

			//Build the path to which the files will be extracted
			//Name of the folder will be of the format {timestamp}_{zip file name}
			_extractionPath = Path.Combine(_extractedFilesRoot, $"{DateTime.Now.ToString("yyyyMMddHHmmssfff")}_{Path.GetFileNameWithoutExtension(zipFilePath)}");

			//Create that folder
			try
			{
				Directory.CreateDirectory(_extractionPath);
			}
			catch
			{
				return new FileExtractionResult { Errors = new List<string> { "Unable to create extraction directory" } };
			}

			//Open the zip file as a read-only stream and create a read-only ZipArchive object from it. This doesn't extract, basically does a directory listing.
			//Then call the logic that extracts the content of the ZipArchive as is needed
			try
			{
				using (ZipArchive archive = new ZipArchive(File.OpenRead(zipFilePath), ZipArchiveMode.Read))
				{
					switch (_submissionType)
					{
						case SubmissionType.New:
							RecursivelyExtractNew(archive);
							break;
						case SubmissionType.Update:
							RecursivelyExtractUpdate(archive);
							break;
						case SubmissionType.Change:
							RecursivelyExtractChange(archive);
							break;
						default:
							return new FileExtractionResult { Errors = new List<string> { "Invalid submission type" } };
					}
				}
			}
			catch
			{
				return new FileExtractionResult { Errors = new List<string> { "Unable to extract contents of zip file" } };
			}

			return new FileExtractionResult { ExtractionPath = _extractionPath };
		}


		//Note - these 3 extraction methods are very similar, but between the recursion and the slight variances it isn't worth the trouble to make it one method with internal variations

		private void RecursivelyExtractNew(ZipArchive archive)
		{
			//Filter down to the relevant files we want to persist. This includes inf files and Summary files - KAS ECC/FFC is SummaryFile.txt for some reason. ._ exclusion is for Mac garbage filtering
			IEnumerable<ZipArchiveEntry> relevantFiles = archive.Entries.Where(e => !e.Name.StartsWith("._") && (e.Name.EndsWith(".inf") || e.Name.EndsWith("Summary.txt") || e.Name.EndsWith("SummaryFile.txt")));

			//Since this is just a mass of files, need to group them by the path in order to pick out the distinct OE (or whatever) folders containing these files. Each distinct path gets saved as a distinct directory under this submission's root
			foreach (var group in relevantFiles.GroupBy(f => f.FullName.Substring(0, f.FullName.Length - f.Name.Length)))
			{
				//Confirm that the group contains an inf file before doing any work with the files, just to be safe
				if (group.Any(f => f.Name.EndsWith(".inf")))
				{
					//Create the directory
					_folderCount++;
					Directory.CreateDirectory(Path.Combine(_extractionPath, _folderCount.ToString()));

					//Extract the inf and summary files to a directory
					foreach (var file in group)
					{
						file.ExtractToFile(Path.Combine(_extractionPath, _folderCount.ToString(), file.Name));		//Directories will be 1 to n under the submission root
					}
				}
			}

			//Now work with any nested zip files. Hopefully there aren't any.
			IEnumerable<ZipArchiveEntry> nestedZipFiles = archive.Entries.Where(e => e.Name.EndsWith(".zip") && !e.Name.StartsWith("._"));

			foreach (ZipArchiveEntry zipFile in nestedZipFiles)
			{
				//Open the nested zip file as a stream
				using (ZipArchive childArchive = new ZipArchive(zipFile.Open(), ZipArchiveMode.Read))	//There seems to be no way to force the stream to be read-only
				{
					RecursivelyExtractNew(childArchive);
				}
			}
		}

		private void RecursivelyExtractChange(ZipArchive archive)
		{
			//Filter down to the relevant files we want to persist. This is just the Change_Req_File.txt files. ._ exclusion is for Mac garbage filtering
			IEnumerable<ZipArchiveEntry> relevantFiles = archive.Entries.Where(e => !e.Name.StartsWith("._")
																				&& (e.Name.EndsWith("Change_Req_File.txt")
																					|| (e.Name.EndsWith(".pdf") && e.Name.ToLower().Contains("change"))));		//PDF is not generated by CAVS, so hoping that they named it with some casing of "change"

			//While there really only should be one change file, there's a chance that there are multiple. For now, just get them all, potentially error out at a higher level
			foreach (ZipArchiveEntry file in relevantFiles)
			{
				//Create a directory for this file
				_folderCount++;
				Directory.CreateDirectory(Path.Combine(_extractionPath, _folderCount.ToString()));

				//Extract the file to a directory
				file.ExtractToFile(Path.Combine(_extractionPath, _folderCount.ToString(), file.Name));      //Directories will be 1 to n under the submission root
			}

			//Now work with any nested zip files. Hopefully there aren't any.
			IEnumerable<ZipArchiveEntry> nestedZipFiles = archive.Entries.Where(e => e.Name.EndsWith(".zip") && !e.Name.StartsWith("._"));

			foreach (ZipArchiveEntry zipFile in nestedZipFiles)
			{
				//Open the nested zip file as a stream
				using (ZipArchive childArchive = new ZipArchive(zipFile.Open(), ZipArchiveMode.Read))   //There seems to be no way to force the stream to be read-only
				{
					RecursivelyExtractChange(childArchive);
				}
			}
		}

		private void RecursivelyExtractUpdate(ZipArchive archive)
		{
			//Filter down to the relevant files we want to persist. This includes inf files, Summary files, and the update file - KAS ECC/FFC is SummaryFile.txt for some reason. ._ exclusion is for Mac garbage filtering
			IEnumerable<ZipArchiveEntry> relevantFiles = archive.Entries.Where(e => !e.Name.StartsWith("._")
																				&& (e.Name.EndsWith(".inf")
																					|| e.Name.EndsWith("Summary.txt")
																					|| e.Name.EndsWith("SummaryFile.txt")
																					|| e.Name.EndsWith("Update_Req_File.txt")
																					|| (e.Name.EndsWith(".pdf") && e.Name.ToLower().Contains("update"))));	//PDF is not generated by CAVS, so hoping that they named it with some casing of "update"

			//Since this is just a mass of files, need to group them by the path in order to pick out the distinct OE (or whatever) folders containing these files. Each distinct path gets saved as a distinct directory under this submission's root
			foreach (var group in relevantFiles.GroupBy(f => f.FullName.Substring(0, f.FullName.Length - f.Name.Length)))
			{
				//Confirm that the group contains an inf file before doing any work with the files, just to be safe
				if (group.Any(f => f.Name.EndsWith(".inf")))
				{
					//Create the directory
					_folderCount++;
					Directory.CreateDirectory(Path.Combine(_extractionPath, _folderCount.ToString()));

					//Extract the inf and summary files to a directory
					foreach (var file in group)
					{
						file.ExtractToFile(Path.Combine(_extractionPath, _folderCount.ToString(), file.Name));      //Directories will be 1 to n under the submission root
					}
				}
			}

			//Now work with any nested zip files. Hopefully there aren't any.
			IEnumerable<ZipArchiveEntry> nestedZipFiles = archive.Entries.Where(e => e.Name.EndsWith(".zip") && !e.Name.StartsWith("._"));

			foreach (ZipArchiveEntry zipFile in nestedZipFiles)
			{
				//Open the nested zip file as a stream
				using (ZipArchive childArchive = new ZipArchive(zipFile.Open(), ZipArchiveMode.Read))   //There seems to be no way to force the stream to be read-only
				{
					RecursivelyExtractUpdate(childArchive);
				}
			}
		}
	}
}
